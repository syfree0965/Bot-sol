require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const NodeCache = require('node-cache');
const winston = require('winston');
const express = require('express');
const bodyParser = require('body-parser');
const fetch = require('node-fetch');

// ======== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© ========
const BOT_TOKEN = process.env.BOT_TOKEN;
const MORALIS_API_KEY = process.env.MORALIS_API_KEY;
const PORT = process.env.PORT || 3000;

if (!BOT_TOKEN || !MORALIS_API_KEY) {
  console.error('ÙŠØ¬Ø¨ ØªØ¹ÙŠÙŠÙ† BOT_TOKEN Ùˆ MORALIS_API_KEY ÙÙŠ Ø§Ù„Ø¨ÙŠØ¦Ø©!');
  process.exit(1);
}

// ØªØ³Ø¬ÙŠÙ„ ØªØ­Ù…ÙŠÙ„ Ù…ÙØªØ§Ø­ API
console.log(`Ù…ÙØªØ§Ø­ API Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${MORALIS_API_KEY ? 'ØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡' : 'ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'}`);

// ======== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø³Ø¬Ù„ (Logger) ========
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({ format: winston.format.simple() })
  ]
});

logger.info(`Ù…ÙØªØ§Ø­ API Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${MORALIS_API_KEY ? 'ØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡' : 'ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'}`);

// ======== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª ========
const tokenCache = new NodeCache({ stdTTL: 300 });
const userCache = new NodeCache();

// ======== ØªÙ‡ÙŠØ¦Ø© Ø¨ÙˆØª Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù… Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø§Ø³ØªØ·Ù„Ø§Ø¹ ========
const bot = new TelegramBot(BOT_TOKEN, { polling: true });

bot.on('polling_error', (error) => {
  logger.error(`Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ·Ù„Ø§Ø¹ Telegram: ${error.message}`, { stack: error.stack });
});

// ======== ØªÙ‡ÙŠØ¦Ø© Ø®Ø§Ø¯Ù… Express Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) ========
const app = express();
app.use(bodyParser.json());

// ======== Ø¯Ø§Ù„Ø© ØªÙ‡Ø±ÙŠØ¨ Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„Ø®Ø§ØµØ© Ù„Ù…Ø§Ø±ÙƒØ¯Ø§ÙˆÙ† ========
function escapeMarkdown(text) {
  if (typeof text !== 'string') text = String(text);
  const reservedChars = /([_*[\]()~`>#+\-=|{}.!\\])/g;
  return text.replace(reservedChars, '\\$1');
}

// ======== Ø¯Ø§Ù„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…ÙŠÙ†Øª Ù…Ù† Ø§Ù„Ø³Ø¬Ù„Ø§Øª (Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ) ========
function extractMintAddressFromLogs(logs) {
  for (const log of logs) {
    if (log.startsWith('Program log: Mint pubkey:')) {
      const parts = log.split(':');
      if (parts.length >= 2) {
        return parts[1].trim();
      }
    }
  }
  return null;
}

// ======== ÙÙ„ØªØ± Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø²ÙŠÙØ©/Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø© ========
function isSuspiciousToken(tokenInfo) {
  const suspiciousPatterns = [
    /BTC/i, /ETH/i, /SOL/i, /USDT/i, /USDC/i, // ØªØ´Ø§Ø¨Ù‡ Ù…Ø¹ Ø¹Ù…Ù„Ø§Øª Ù…Ø¹Ø±ÙˆÙØ©
    /^[A-Za-z0-9]{1,3}$/, // Ø±Ù…ÙˆØ² Ù‚ØµÙŠØ±Ø© Ø¬Ø¯Ù‹Ø§
    /^[^A-Za-z0-9]+$/, // Ø£Ø­Ø±Ù ØºØ±ÙŠØ¨Ø© ÙÙ‚Ø·
  ];
  const name = tokenInfo.name || '';
  const symbol = tokenInfo.symbol || '';
  const socials = tokenInfo.socials || {};

  for (const pattern of suspiciousPatterns) {
    if (pattern.test(name) || pattern.test(symbol)) {
      logger.debug(`ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø¹Ù…Ù„Ø© Ø¨Ø³Ø¨Ø¨ Ø§Ø³Ù…/Ø±Ù…Ø² Ù…Ø´Ø¨ÙˆÙ‡: ${name}/${symbol}`, { mint: tokenInfo.mint });
      return true;
    }
  }

  // ÙÙ„ØªØ± Ø§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ (Ù…Ø¹Ø·Ù„ØŒ Ù‚Ù… Ø¨Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ Ù„ØªÙØ¹ÙŠÙ„Ù‡)
  /*
  if (!socials.twitter && !socials.telegram) {
    logger.debug(`ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø¹Ù…Ù„Ø© Ø¨Ø³Ø¨Ø¨ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø±ÙˆØ§Ø¨Ø· X Ø£Ùˆ Telegram`, { mint: tokenInfo.mint });
    return true;
  }
  */

  return false;
}

// ======== Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø¹ ØªØ£Ø®ÙŠØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠ ========
async function fetchWithRetry(url, options, retries = 5, baseDelay = 3000) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url, options);
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
      }
      return response;
    } catch (error) {
      if (i < retries - 1) {
        const jitter = Math.random() * 100;
        const delay = baseDelay + jitter;
        logger.warn(`ÙØ´Ù„ Ø§Ù„Ø·Ù„Ø¨ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ${i + 1}/${retries} Ø¨Ø¹Ø¯ ${delay}ms: ${error.message}`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      throw error;
    }
  }
}

// ======== Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¹Ø¨Ø± Moralis Pump Fun API ========
async function pollNewTokens(userId) {
  try {
    const response = await fetchWithRetry(
      'https://solana-gateway.moralis.io/token/mainnet/exchange/pumpfun/new?limit=20',
      {
        method: 'GET',
        headers: {
          accept: 'application/json',
          'X-API-Key': MORALIS_API_KEY
        }
      }
    );

    const data = await response.json();
    logger.info(`ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ${data.result?.length || 0} Ø¹Ù…Ù„Ø© Ù…Ù† Moralis API`, { response: data });

    if (data.result && Array.isArray(data.result) && data.result.length > 0) {
      const latestToken = data.result.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))[0];
      const coin = {
        mint: latestToken.tokenAddress,
        created_at: latestToken.createdAt
      };
      await handleNewToken(coin, 'pumpfun', userId);
    } else {
      logger.info('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù…Ù„Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©');
      await bot.sendMessage(userId, escapeMarkdown('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù…Ù„Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù„Ø­Ø¸Ø©'), { parse_mode: 'MarkdownV2' });
    }
  } catch (error) {
    logger.error(`Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Moralis: ${error.message}`, { stack: error.stack });
    await bot.sendMessage(userId, escapeMarkdown(`âŒ Ø®Ø·Ø£: ${error.message}`), { parse_mode: 'MarkdownV2' });
  }
}

// ======== Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ========
async function handleNewToken(coin, service, userId) {
  try {
    const createdAt = new Date(coin.created_at).getTime();
    const ageInSeconds = Math.floor((Date.now() - createdAt) / 1000);
    if (ageInSeconds > 60) {
      logger.debug(`ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø¹Ù…Ù„Ø© Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø¹Ù…Ø±: ${ageInSeconds} Ø«Ø§Ù†ÙŠØ©`, { mint: coin.mint });
      return;
    }
    if (tokenCache.has(coin.mint)) {
      logger.debug(`ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø¹Ù…Ù„Ø© Ø¨Ø³Ø¨Ø¨ ÙˆØ¬ÙˆØ¯Ù‡Ø§ ÙÙŠ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª: ${coin.mint}`);
      return;
    }
    const tokenInfo = await getTokenInfo(coin.mint);
    if (isSuspiciousToken(tokenInfo)) {
      return;
    }
    tokenCache.set(coin.mint, true);
    await broadcastNewToken(coin, ageInSeconds, service, userId);
  } catch (error) {
    logger.error(`Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† ${service}: ${error.message}`, { stack: error.stack, coin });
    await bot.sendMessage(userId, escapeMarkdown(`âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ù…Ù„Ø©: ${error.message}`), { parse_mode: 'MarkdownV2' });
  }
}

// ======== Ø¨Ø« Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ========
async function broadcastNewToken(coin, ageInSeconds, service, userId) {
  try {
    const tokenInfo = await getTokenInfo(coin.mint);
    const message = formatTokenMessage(tokenInfo, ageInSeconds);
    await bot.sendMessage(userId, message, { parse_mode: 'MarkdownV2', disable_web_page_preview: true });
    logger.info(`ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¹Ù…Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¥Ù„Ù‰ ${userId} Ø¹Ø¨Ø± ${service}`, { userId, service, mint: coin.mint });
    // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø³ØªØ·Ù„Ø§Ø¹ Ø¨Ø¹Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ù†ØªÙŠØ¬Ø© ÙˆØ§Ø­Ø¯Ø©
    userCache.del(userId);
    isPolling = false;
    await bot.sendMessage(userId, escapeMarkdown('ğŸ›‘ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©. Ø§Ø¶ØºØ· "Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¹Ø¨Ø± Pump.fun" Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙØ¹ÙŠÙ„.'), { parse_mode: 'MarkdownV2' });
  } catch (error) {
    logger.error(`Ø®Ø·Ø£ ÙÙŠ Ø¨Ø« Ø§Ù„Ø¹Ù…Ù„Ø© Ù…Ù† ${service}: ${error.message}`, { stack: error.stack, coin });
    await bot.sendMessage(userId, escapeMarkdown(`âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¹Ù…Ù„Ø©: ${error.message}`), { parse_mode: 'MarkdownV2' });
  }
}

// ======== Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¹Ù…Ù„Ø© ========
async function getTokenInfo(tokenAddress) {
  const tokenInfo = { name: 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ', symbol: '?', price: 0, liquidity: 0, marketCap: 0, mint: tokenAddress, socials: {} };
  try {
    const response = await fetchWithRetry(
      `https://solana-gateway.moralis.io/token/mainnet/${tokenAddress}/price`,
      {
        method: 'GET',
        headers: {
          accept: 'application/json',
          'X-API-Key': MORALIS_API_KEY
        }
      }
    );

    const data = await response.json();
    tokenInfo.name = data.name || tokenInfo.name;
    tokenInfo.symbol = data.symbol || tokenInfo.symbol;
    tokenInfo.price = data.usdPrice || tokenInfo.price;
    tokenInfo.liquidity = data.liquidity?.usd || tokenInfo.liquidity;
    tokenInfo.marketCap = data.fullyDilutedValuation || tokenInfo.marketCap;
    tokenInfo.socials = data.socials || tokenInfo.socials;
  } catch (error) {
    logger.error(`Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆÙƒÙ†: ${error.message}`, { stack: error.stack, mint: tokenAddress });
  }
  return tokenInfo;
}

// ======== ØªÙ†Ø³ÙŠÙ‚ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ ========
function formatTokenMessage(tokenInfo, ageInSeconds) {
  const socialLinks = [];
  if (tokenInfo.socials.twitter) {
    socialLinks.push(`[${escapeMarkdown('X')}](https://x.com/${escapeMarkdown(tokenInfo.socials.twitter.replace('https://x.com/', ''))})`);
  }
  if (tokenInfo.socials.telegram) {
    socialLinks.push(`[${escapeMarkdown('Telegram')}](https://t.me/${escapeMarkdown(tokenInfo.socials.telegram.replace('https://t.me/', ''))})`);
  }
  if (tokenInfo.socials.website) {
    socialLinks.push(`[${escapeMarkdown('Website')}](https://website/${escapeMarkdown(tokenInfo.socials.website.replace('https://website/', ''))})`);
  }
  const socialsText = socialLinks.length > 0 ? socialLinks.join(' | ') : 'ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©';

  return `
ğŸš€ *${escapeMarkdown('ØªÙ… Ø¥Ø·Ù„Ø§Ù‚ Ø¹Ù…Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¹Ù„Ù‰ Pump.fun!')}*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸª™ *${escapeMarkdown('Ø§Ù„Ø§Ø³Ù…:')}* ${escapeMarkdown(tokenInfo.name)}
ğŸ”¤ *${escapeMarkdown('Ø§Ù„Ø±Ù…Ø²:')}* ${escapeMarkdown(tokenInfo.symbol)}
ğŸ’° *${escapeMarkdown('Ø§Ù„Ø³Ø¹Ø±:')}* $${escapeMarkdown((tokenInfo.price?.toFixed(6) || '0.000000'))}
ğŸ“Š *${escapeMarkdown('Ø§Ù„Ø³ÙŠÙˆÙ„Ø©:')}* $${escapeMarkdown(tokenInfo.liquidity.toFixed(2))}
ğŸ¦ *${escapeMarkdown('Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø³ÙˆÙ‚ÙŠØ©:')}* $${escapeMarkdown(tokenInfo.marketCap.toFixed(2))}
â±ï¸ *${escapeMarkdown('Ø§Ù„Ø¹Ù…Ø±:')}* ${escapeMarkdown(ageInSeconds.toString())} ${escapeMarkdown('Ø«Ø§Ù†ÙŠØ©')}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”— *${escapeMarkdown('Ø±Ø§Ø¨Ø· Ø§Ù„Ø¹Ù…Ù„Ø©:')}* [${escapeMarkdown('Pump.fun')}](https://pump.fun/${escapeMarkdown(tokenInfo.mint)})
ğŸŒ *${escapeMarkdown('Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªÙˆØ§ØµÙ„:')}* ${socialsText}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ *${escapeMarkdown('Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¹Ù‚Ø¯:')}* \`${escapeMarkdown(tokenInfo.mint)}\`
`.trim();
}

// ======== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ========
bot.onText(/\/start/, async (msg) => {
  const userId = msg.from.id;
  const keyboard = {
    inline_keyboard: [
      [{ text: 'ğŸš€ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¹Ø¨Ø± Pump.fun', callback_data: 'select_pumpfun' }],
      [{ text: 'âŒ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©', callback_data: 'stop_monitoring' }],
      [{ text: 'ğŸ”„ Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…', callback_data: 'system_status' }]
    ]
  };
  await bot.sendMessage(userId, 'Ù…Ø±Ø­Ø¨Ù‹Ø§! Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¹Ù„Ù‰ Pump.fun:', { reply_markup: keyboard });
});

bot.on('callback_query', async (query) => {
  const userId = query.from.id;
  const data = query.data;
  await bot.answerCallbackQuery(query.id);
  if (data === 'select_pumpfun') {
    userCache.set(userId, 'pumpfun');
    await bot.sendMessage(userId, escapeMarkdown('âœ… *ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¹Ø¨Ø± Pump.fun! Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù…Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©...*'), { parse_mode: 'MarkdownV2' });
    await pollNewTokens(userId); // Ø§Ø³ØªØ·Ù„Ø§Ø¹ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©
  } else if (data === 'stop_monitoring') {
    userCache.del(userId);
    isPolling = false;
    await bot.sendMessage(userId, escapeMarkdown('ğŸ›‘ *ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©!*'), { parse_mode: 'MarkdownV2' });
  } else if (data === 'system_status') {
    const usersPumpFun = userCache.keys().filter(key => userCache.get(key) === 'pumpfun').length;
    const status = escapeMarkdown(`
*Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…:*
â€¢ Pump.fun: ${isPolling ? 'ğŸŸ¢ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù†Ø´Ø·Ø©' : 'ğŸ”´ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ØºÙŠØ± Ù†Ø´Ø·Ø©'}
â€¢ Ù…Ø³ØªØ®Ø¯Ù…Ùˆ Pump.fun: ${usersPumpFun}
    `).trim();
    await bot.sendMessage(userId, status, { parse_mode: 'MarkdownV2' });
  }
});

// ======== Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ÙØªØ§Ø­ API ========
async function checkApiKey() {
  try {
    const response = await fetchWithRetry(
      'https://solana-gateway.moralis.io/token/mainnet/9BB6NFEcjBCtnNLFko2FqVQBq8HHM13kCyYcdQbgpump/price',
      {
        method: 'GET',
        headers: {
          accept: 'application/json',
          'X-API-Key': MORALIS_API_KEY
        }
      }
    );
    logger.info('Ù…ÙØªØ§Ø­ API ØµØ§Ù„Ø­ØŒ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©...');
  } catch (error) {
    logger.error(`Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ÙØªØ§Ø­ API: ${error.message}`, { stack: error.stack });
    process.exit(1);
  }
}

// ======== Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø®Ø§Ø¯Ù… ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ÙØªØ§Ø­ API ========
app.listen(PORT, () => logger.info(`Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ÙØ° ${PORT}`));
checkApiKey();
logger.info('ØªÙ… Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­!');